import { IAsyncEMWWrapper, ISyncEMWWrapper, IRunResult } from './wrapper';
export interface IModuleMessage {
    key: string;
}
export interface IErrorReplyMessage extends IModuleMessage {
    type: 'error';
    error: Error;
    stdout: string;
    stderr: string;
}
export interface IOkReplyMessage extends IModuleMessage {
    type: 'ok';
}
export interface IMainRequestMessage extends IModuleMessage {
    type: 'run';
    args?: string[];
    stdin?: string;
}
export interface IMainReplyMessage extends IModuleMessage, IRunResult {
    type: 'run';
}
export interface IFunctionRequestMessage extends IModuleMessage {
    type: 'fn';
    function: string;
    args: (string | number | Uint8Array)[];
}
export interface IFunctionReplyMessage extends IModuleMessage {
    type: 'fn';
    function: string;
    returnValue: (string | number | boolean | null);
}
export interface ISetEnvironmentVariableRequestMessage extends IModuleMessage {
    type: 'setEnv';
    name: string;
    value: string;
}
export interface IWriteTextFileRequestMessage extends IModuleMessage {
    type: 'writeTextFile';
    path: string;
    content: string;
}
export interface IWriteBinaryFileRequestMessage extends IModuleMessage {
    type: 'writeBinaryFile';
    path: string;
    content: ArrayBufferView;
}
export interface IReadTextFileRequestMessage extends IModuleMessage {
    type: 'readTextFile';
    path: string;
}
export interface IReadTextFileReplyMessage extends IModuleMessage {
    type: 'readTextFile';
    path: string;
    content: string;
}
export interface IReadBinaryFileRequestMessage extends IModuleMessage {
    type: 'readBinaryFile';
    path: string;
}
export interface IReadBinaryFileReplyMessage extends IModuleMessage {
    type: 'readBinaryFile';
    path: string;
    content: ArrayBufferView;
}
export interface IStdOutReplyMessage extends IModuleMessage {
    type: 'stdout';
    chunk: string;
}
export interface IStdInRequestMessage extends IModuleMessage {
    type: 'stdin';
    chunk: string;
}
export interface IClearStdInRequestMessage extends IModuleMessage {
    type: 'stdinClear';
}
export interface IReInRequestMessage extends IModuleMessage {
    type: 'stdinClose';
}
export interface ICloseStdInRequestMessage extends IModuleMessage {
    type: 'stdinClose';
}
export interface IStdErrReplyMessage extends IModuleMessage {
    type: 'stderr';
    chunk: string;
}
export interface IReadyReplyMessage extends IModuleMessage {
    type: 'ready';
}
export interface IExitReplyMessage extends IModuleMessage {
    type: 'exit';
    code: number;
}
export interface IQuitReplyMessage extends IModuleMessage {
    type: 'quit';
    status: number;
}
export interface IEnsureDirRequestMessage extends IModuleMessage {
    type: 'ensureDir';
    path: string;
}
export interface IBatchRequestMessage extends IModuleMessage {
    type: 'batch';
    messages: IRequestMessage[];
}
export interface IBatchReplyMessage extends IModuleMessage {
    type: 'batch';
    replies: IReplyMessage[];
}
export declare type IRequestMessage = IBatchRequestMessage | IStdInRequestMessage | IClearStdInRequestMessage | ICloseStdInRequestMessage | IEnsureDirRequestMessage | IMainRequestMessage | IFunctionRequestMessage | ISetEnvironmentVariableRequestMessage | IWriteTextFileRequestMessage | IWriteBinaryFileRequestMessage | IReadTextFileRequestMessage | IReadBinaryFileRequestMessage;
export declare type IReplyMessage = IBatchReplyMessage | IOkReplyMessage | IReadyReplyMessage | IExitReplyMessage | IQuitReplyMessage | IErrorReplyMessage | IFunctionReplyMessage | IStdOutReplyMessage | IStdErrReplyMessage | IMainReplyMessage | IReadTextFileReplyMessage | IReadBinaryFileReplyMessage;
export declare type IReplyer = (msg: IModuleMessage & {
    [key: string]: any;
}, transfer?: Transferable[]) => void;
export interface IMessageAdapter {
    postMessage(msg: any, transfer?: Transferable[]): void;
    addEventListener(type: 'message', listener: (msg: any, reply: (msg: any, transfer?: Transferable[]) => void) => void): void;
}
export declare class ModuleWorker<FN = {}, T extends IAsyncEMWWrapper<FN> = IAsyncEMWWrapper<FN>> {
    protected readonly module: T;
    protected readonly adapter: IMessageAdapter;
    constructor(module: T, adapter?: IMessageAdapter);
    protected streamOut(mod: ISyncEMWWrapper<FN>, msg: IModuleMessage, run: () => void, reply: IReplyer): Promise<void>;
    private run;
    private fn;
    private setEnv;
    private stdin;
    protected ok(msg: IModuleMessage): {
        key: string;
        type: string;
    };
    private stdinClear;
    private stdinClose;
    private writeTextFile;
    private writeBinaryFile;
    private ensureDir;
    private readTextFile;
    private readBinaryFile;
    private batch;
    protected handleModuleMessage(mod: ISyncEMWWrapper<FN>, msg: IRequestMessage, reply: IReplyer): void;
    protected handleMessage(msg: IRequestMessage, reply: IReplyer): void;
    private onMessage;
}
//# sourceMappingURL=ModuleWorker.d.ts.map