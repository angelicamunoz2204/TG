"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var stream_1 = require("./stream");
var ModuleWorker_1 = require("./ModuleWorker");
var utils_1 = require("./utils");
var ModuleWorkerClient_1 = require("./ModuleWorkerClient");
function loadHelper(fn) {
    if (!fn) {
        return Promise.resolve(null);
    }
    return Promise.resolve(fn()).then(function (modOrDefault) {
        if (modOrDefault && typeof modOrDefault.default !== 'undefined') {
            return modOrDefault.default;
        }
        return modOrDefault;
    });
}
function string2arrayBuffer(str) {
    var buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char
    var bufView = new Uint16Array(buf);
    for (var i = 0; i < str.length; i++) {
        bufView[i] = str.charCodeAt(i);
    }
    return buf;
}
function buildAsyncFunctions(that, functions) {
    if (functions === void 0) { functions = {}; }
    var obj = {};
    Object.keys(functions).forEach(function (k) {
        obj[k] = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return that.sync().then(function (mod) {
                var _a;
                return (_a = mod.fn)[k].apply(_a, args);
            });
        };
    });
    return obj;
}
function buildSyncFunctions(mod, functions) {
    if (functions === void 0) { functions = {}; }
    var obj = {};
    Object.entries(functions).forEach(function (_a) {
        var k = _a[0], v = _a[1];
        obj[k] = mod.cwrap(k, v.returnType, v.arguments);
    });
    return obj;
}
var EMScriptWrapper = /** @class */ (function (_super) {
    __extends(EMScriptWrapper, _super);
    function EMScriptWrapper(_loaders, options) {
        if (options === void 0) { options = {}; }
        var _this = _super.call(this) || this;
        _this._loaders = _loaders;
        _this.options = options;
        _this.stdout = new stream_1.SimpleOutStream();
        _this.stderr = new stream_1.SimpleOutStream();
        _this.stdin = new stream_1.SimpleInStream();
        _this.moduleLoader = null;
        _this.readySemaphore = null;
        _this._sync = null;
        _this.environmentVariables = {};
        _this.ranMainOnce = false;
        _this.fn = buildAsyncFunctions(_this, options.functions);
        _this.simpleFileSystem = {
            ensureDir: function (dir) { return _this.fileSystem.then(function (fs) {
                utils_1.ensureDir(fs, dir);
                return true;
            }); },
            readBinaryFile: function (path) { return _this.fileSystem.then(function (fs) {
                return fs.readFile(path);
            }); },
            readTextFile: function (path) { return _this.fileSystem.then(function (fs) {
                return fs.readFile(path, { encoding: 'utf8', flags: 'r' });
            }); },
            writeTextFile: function (path, content) { return _this.fileSystem.then(function (fs) {
                fs.writeFile(path, content, { encoding: 'utf8', flags: 'w' });
                return true;
            }); },
            writeBinaryFile: function (path, content) { return _this.fileSystem.then(function (fs) {
                fs.writeFile(path, content);
                return true;
            }); }
        };
        return _this;
    }
    EMScriptWrapper.prototype._load = function () {
        var _this = this;
        if (this.moduleLoader) {
            return this.moduleLoader;
        }
        var readyResolve = null;
        this.readySemaphore = new Promise(function (resolve) { return readyResolve = resolve; });
        this.moduleLoader = Promise.all([loadHelper(this._loaders.module), loadHelper(this._loaders.wasm), loadHelper(this._loaders.mem), loadHelper(this._loaders.data)]).then(function (_a) {
            var mod = _a[0], wasm = _a[1], mem = _a[2], data = _a[3];
            var modOptions = {
                // readd missing new line
                print: function (chunk) { return _this.stdout.push(chunk + "\n"); },
                printErr: function (chunk) { return _this.stderr.push(chunk + "\n"); },
                stdin: function () { return _this.stdin.read(); },
                noInitialRun: true,
                noExitRuntime: true,
                onRuntimeInitialized: function () {
                    setTimeout(function () { return readyResolve(); }, 1);
                },
                quit: function (status) {
                    _this.emit('quit', status);
                }
            };
            // console.log(wasm, data, mem);
            var toLocate = [];
            // WASM
            if (wasm instanceof ArrayBuffer || (typeof wasm === 'string' && !wasm.endsWith('.wasm'))) {
                // array buffer or a string which is an arraybuffer
                if (typeof wasm === 'string') {
                    wasm = string2arrayBuffer(wasm);
                }
                modOptions.wasmBinary = wasm;
            }
            else if (typeof wasm === 'string') {
                // location
                toLocate.push({ suffix: '.wasm', location: wasm });
            }
            // DATA
            if (data instanceof ArrayBuffer || (typeof data === 'string' && !data.endsWith('.data'))) {
                // array buffer or a string which is an arraybuffer
                var d_1 = (typeof data === 'string') ? string2arrayBuffer(data) : data;
                modOptions.getPreloadedPackage = function () { return d_1; };
            }
            else if (typeof data === 'string') {
                // location
                toLocate.push({ suffix: '.data', location: data });
            }
            // MemoryDump
            if (mem instanceof ArrayBuffer || (typeof mem === 'string' && !mem.endsWith('.mem'))) {
                // array buffer or a string which is an arraybuffer
                if (typeof mem === 'string') {
                    mem = string2arrayBuffer(mem);
                }
                modOptions.memoryInitializerRequest = { response: mem, status: 200 };
            }
            else if (typeof mem === 'string') {
                // location
                toLocate.push({ suffix: '.mem', location: mem });
            }
            if (toLocate.length > 0) {
                modOptions.locateFile = function (name, prefix) {
                    var entry = toLocate.find(function (d) { return name.endsWith(d.suffix); });
                    return entry ? entry.location : "" + (prefix || '') + name;
                };
            }
            var m = mod(modOptions);
            // wrap module since it has a 'then' by itself and then the promise thinks it is another promise to wait for
            // however the then doesn't work properly
            return { mod: m };
        });
        return this.moduleLoader;
    };
    EMScriptWrapper.prototype.main = function (args) {
        return this.sync().then(function (mod) { return mod.main(args); });
    };
    EMScriptWrapper.prototype.run = function (args, stdin) {
        return this.sync().then(function (mod) { return mod.run(args, stdin); });
    };
    EMScriptWrapper.prototype.kill = function (signal) {
        return this.sync().then(function (mod) { return mod.kill(signal); });
    };
    Object.defineProperty(EMScriptWrapper.prototype, "fileSystem", {
        get: function () {
            return this._load().then(function (mod) { return mod.mod.FS; });
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EMScriptWrapper.prototype, "module", {
        get: function () {
            return this._load().then(function (mod) { return mod.mod; });
        },
        enumerable: true,
        configurable: true
    });
    EMScriptWrapper.prototype._callMain = function (mod, args) {
        var statusCode = 0;
        var statusError = null;
        var quitListener = function (status, error) {
            statusCode = status;
            statusError = error;
        };
        this.on('quit', quitListener);
        try {
            this.preMain(mod);
            mod.callMain(args || []);
            if (statusCode > 0 && statusError) {
                throw statusError;
            }
            return statusCode;
        }
        finally {
            this.off('quit', quitListener);
        }
    };
    EMScriptWrapper.prototype.preMain = function (mod) {
        // call to init the proper standard streams agains
        if (this.ranMainOnce && mod.globalCtors) {
            // globalctors: A demonstration of GCC Global Constructor: A function that is automatically called before main.
            mod.globalCtors();
        }
        this.ranMainOnce = true;
    };
    EMScriptWrapper.prototype._runMain = function (mod, args, stdin) {
        var statusCode = 0;
        var statusError = null;
        var stdout = '';
        var stderr = '';
        var quitListener = function (status, error) {
            statusCode = status;
            statusError = error;
        };
        this.on('quit', quitListener);
        var stdoutListener = function (chunk) {
            stdout += chunk;
        };
        this.stdout.on('data', stdoutListener);
        var stderrListener = function (chunk) {
            stderr += chunk;
        };
        this.stderr.on('data', stderrListener);
        if (stdin) {
            this.stdin.clear();
            this.stdin.push(stdin);
        }
        try {
            this.preMain(mod);
            mod.callMain(args || []);
        }
        catch (error) {
            statusError = error;
        }
        finally {
            this.off('quit', quitListener);
            this.stdout.off('data', stdoutListener);
            this.stderr.off('data', stderrListener);
            if (stdin) {
                this.stdin.clear();
            }
        }
        return {
            stdout: stdout,
            stderr: stderr,
            exitCode: statusCode,
            error: statusError || undefined
        };
    };
    EMScriptWrapper.prototype.module2wrapper = function (mod) {
        var _this = this;
        var that = this;
        var environmentVariables = mod.ENV && typeof mod.ENV !== 'function' ? mod.ENV : {};
        // inject environment variables that where set before
        Object.assign(environmentVariables, this.environmentVariables);
        this.environmentVariables = environmentVariables;
        return {
            module: mod,
            fileSystem: mod.FS,
            environmentVariables: environmentVariables,
            on: function (event, listener) {
                that.on(event, listener);
                return this;
            },
            once: function (event, listener) {
                that.once(event, listener);
                return this;
            },
            prependListener: function (event, listener) {
                that.prependListener(event, listener);
                return this;
            },
            prependOnceListener: function (event, listener) {
                that.prependOnceListener(event, listener);
                return this;
            },
            addListener: function (event, listener) {
                that.addListener(event, listener);
                return this;
            },
            removeListener: function (event, listener) {
                that.removeListener(event, listener);
                return this;
            },
            off: function (event, listener) {
                that.off(event, listener);
                return this;
            },
            removeAllListeners: function (event) {
                that.removeAllListeners(event);
                return this;
            },
            kill: function (signal) { return mod.abort(signal); },
            stderr: this.stderr,
            stdin: this.stdin,
            stdout: this.stdout,
            main: function (args) { return _this._callMain(mod, args); },
            run: function (args, stdin) { return _this._runMain(mod, args, stdin); },
            fn: buildSyncFunctions(mod, this.options.functions),
            simpleFileSystem: {
                ensureDir: function (dir) {
                    utils_1.ensureDir(mod.FS, dir);
                    return Promise.resolve(true);
                },
                readBinaryFile: function (path) {
                    return Promise.resolve(mod.FS.readFile(path));
                },
                readTextFile: function (path) {
                    return Promise.resolve(mod.FS.readFile(path, { encoding: 'utf8', flags: 'r' }));
                },
                writeTextFile: function (path, content) {
                    mod.FS.writeFile(path, content, { encoding: 'utf8', flags: 'w' });
                    return Promise.resolve(true);
                },
                writeBinaryFile: function (path, content) {
                    mod.FS.writeFile(path, content);
                    return Promise.resolve(true);
                }
            }
        };
    };
    EMScriptWrapper.prototype.sync = function () {
        var _this = this;
        if (this._sync) {
            return this._sync;
        }
        return this._sync = this._load()
            .then(function (mod) { return _this.readySemaphore.then(function () { return mod; }); }) // wait for ready
            .then(function (mod) {
            var wrapper = _this.module2wrapper(mod.mod);
            _this.emit('ready', wrapper);
            return wrapper;
        });
    };
    EMScriptWrapper.prototype.emit = function (event) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return _super.prototype.emit.apply(this, [event].concat(args));
    };
    // TODO if there is an exception in ccall and a converter was used (array or string) stackRestore won't be called
    EMScriptWrapper.prototype.createWorker = function (adapter) {
        return new ModuleWorker_1.ModuleWorker(this, adapter);
    };
    EMScriptWrapper.prototype.createWorkerClient = function (worker) {
        return new ModuleWorkerClient_1.ModuleWorkerClient(worker, this.options);
    };
    return EMScriptWrapper;
}(events_1.EventEmitter));
function createWrapper(loaders, options) {
    return new EMScriptWrapper(typeof loaders === 'function' ? { module: loaders } : loaders, options);
}
exports.createWrapper = createWrapper;
exports.default = createWrapper;
//# sourceMappingURL=wrapper.js.map