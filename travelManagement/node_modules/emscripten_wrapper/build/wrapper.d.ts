import { IEMScriptModule, EMScriptFS, IModule } from './module';
import { IEMWInStream, IEMWOutStream } from './stream';
import { ModuleWorker, IMessageAdapter } from './ModuleWorker';
import { IEMWOptions, Promisified, ISimpleFS } from './utils';
import { IEMWWorkerClient, IWorkerLike } from './ModuleWorkerClient';
export interface IRunResult {
    stdout: string;
    stderr: string;
    exitCode: number;
    error?: Error;
}
export interface IEMWMainPromise {
    /**
     * executes the main function returns or throws an error
     * @param args optional main arguments
     */
    main(args?: string[]): Promise<number>;
    /**
     * similar to main but returns a status object including stdout, stderr, and the exitCode
     * @param args optional main arguments
     */
    run(args?: string[], stdin?: string): Promise<IRunResult>;
}
export interface IEMWMain {
    /**
     * executes the main function returns or throws an error
     * @param args optional main arguments
     */
    main(args?: string[]): number;
    /**
     * similar to main but returns a status object including stdout, stderr, and the exitCode
     * @param args optional main arguments
     */
    run(args?: string[], stdin?: string): IRunResult;
}
export interface IEMWWrapper {
    readonly environmentVariables: {
        [key: string]: string;
    };
    kill(signal?: string): void;
    readonly stdin: IEMWInStream;
    readonly stdout: IEMWOutStream;
    readonly stderr: IEMWOutStream;
    addListener(event: 'error', listener: (err: Error) => void): this;
    addListener(event: 'exit', listener: (code: number) => void): this;
    addListener(event: 'quit', listener: (status: number) => void): this;
    on(event: 'error', listener: (err: Error) => void): this;
    on(event: 'exit', listener: (code: number) => void): this;
    on(event: 'quit', listener: (status: number) => void): this;
    once(event: 'error', listener: (err: Error) => void): this;
    once(event: 'exit', listener: (code: number) => void): this;
    once(event: 'quit', listener: (status: number) => void): this;
    prependListener(event: 'error', listener: (err: Error) => void): this;
    prependListener(event: 'exit', listener: (code: number) => void): this;
    prependListener(event: 'quit', listener: (status: number) => void): this;
    prependOnceListener(event: 'error', listener: (err: Error) => void): this;
    prependOnceListener(event: 'exit', listener: (code: number) => void): this;
    prependOnceListener(event: 'quit', listener: (status: number) => void): this;
    removeListener(event: 'error', listener: (err: Error) => void): this;
    removeListener(event: 'exit', listener: (code: number) => void): this;
    removeListener(event: 'quit', listener: (status: number) => void): this;
    off(event: 'error', listener: (err: Error) => void): this;
    off(event: 'exit', listener: (code: number) => void): this;
    off(event: 'quit', listener: (status: number) => void): this;
    removeAllListeners(event?: 'error'): this;
    removeAllListeners(event?: 'exit'): this;
    removeAllListeners(event?: 'quit'): this;
}
export interface ISyncEMWWrapper<T> extends IEMWWrapper {
    readonly fileSystem: EMScriptFS;
    readonly simpleFileSystem: ISimpleFS;
    readonly module: IModule;
    /**
     * object of exposed functions
     */
    readonly fn: T;
}
export interface IAsyncEMWWrapperBase<T = {}> extends IEMWWrapper {
    readonly fileSystem: Promise<EMScriptFS>;
    readonly simpleFileSystem: ISimpleFS;
    readonly module: Promise<IModule>;
    /**
     * object of exposed functions
     */
    readonly fn: Promisified<T>;
    addListener(event: 'ready', listener: (wrapper: ISyncEMWWrapper<T>) => void): this;
    addListener(event: 'error', listener: (err: Error) => void): this;
    addListener(event: 'exit', listener: (code: number) => void): this;
    addListener(event: 'quit', listener: (status: number) => void): this;
    on(event: 'ready', listener: (wrapper: ISyncEMWWrapper<T>) => void): this;
    on(event: 'error', listener: (err: Error) => void): this;
    on(event: 'exit', listener: (code: number) => void): this;
    on(event: 'quit', listener: (status: number) => void): this;
    once(event: 'ready', listener: (wrapper: ISyncEMWWrapper<T>) => void): this;
    once(event: 'error', listener: (err: Error) => void): this;
    once(event: 'exit', listener: (code: number) => void): this;
    once(event: 'quit', listener: (status: number) => void): this;
    prependListener(event: 'ready', listener: (wrapper: ISyncEMWWrapper<T>) => void): this;
    prependListener(event: 'error', listener: (err: Error) => void): this;
    prependListener(event: 'exit', listener: (code: number) => void): this;
    prependListener(event: 'quit', listener: (status: number) => void): this;
    prependOnceListener(event: 'ready', listener: (wrapper: ISyncEMWWrapper<T>) => void): this;
    prependOnceListener(event: 'error', listener: (err: Error) => void): this;
    prependOnceListener(event: 'exit', listener: (code: number) => void): this;
    prependOnceListener(event: 'quit', listener: (status: number) => void): this;
    removeListener(event: 'ready', listener: (wrapper: ISyncEMWWrapper<T>) => void): this;
    removeListener(event: 'error', listener: (err: Error) => void): this;
    removeListener(event: 'exit', listener: (code: number) => void): this;
    removeListener(event: 'quit', listener: (status: number) => void): this;
    off(event: 'ready', listener: (wrapper: ISyncEMWWrapper<T>) => void): this;
    off(event: 'error', listener: (err: Error) => void): this;
    off(event: 'exit', listener: (code: number) => void): this;
    off(event: 'quit', listener: (status: number) => void): this;
    removeAllListeners(event?: 'ready'): this;
    removeAllListeners(event?: 'error'): this;
    removeAllListeners(event?: 'exit'): this;
    removeAllListeners(event?: 'quit'): this;
}
export interface IAsyncEMWWrapper<T = {}> extends IAsyncEMWWrapperBase<T> {
    /**
     * returns a sync version of this wrapper that was resolved then the module is ready
     */
    sync(): Promise<ISyncEMWWrapper<T>>;
    createWorker(adapter?: IMessageAdapter): ModuleWorker<T>;
    createWorkerClient(worker: IWorkerLike): IEMWWorkerClient<T>;
}
export interface IAsyncEMWMainWrapper<T = {}> extends IAsyncEMWWrapperBase<T>, IEMWMainPromise {
    /**
     * returns a sync version of this wrapper that was resolved then the module is ready
     */
    sync(): Promise<ISyncEMWWrapper<T> & IEMWMain>;
    createWorker(adapter?: IMessageAdapter): ModuleWorker<T>;
    createWorkerClient(worker: IWorkerLike): IEMWWorkerClient<T> & IEMWMainPromise;
}
declare type IModuleLike<T> = PromiseLike<T | {
    default: T;
}> | T | {
    default: T;
};
declare type IEMScriptModuleLike = IModuleLike<IEMScriptModule>;
export interface ILoaders {
    module(): IEMScriptModuleLike;
    wasm?(): IModuleLike<string | ArrayBuffer>;
    mem?(): IModuleLike<string | ArrayBuffer>;
    data?(): IModuleLike<string | ArrayBuffer>;
}
/**
 * creates an easy to use wrapper around an emscripten module
 * @param loader loader function to return the emscripten module
 * @param options additional options foremost which functions and whether a main function is available
 */
export declare function createWrapper<T = {}>(loaders: (() => IEMScriptModuleLike) | ILoaders, options?: Partial<IEMWOptions> & {
    main: false;
}): IAsyncEMWWrapper<T>;
export declare function createWrapper<T = {}>(loaders: (() => IEMScriptModuleLike) | ILoaders, options?: Partial<IEMWOptions>): IAsyncEMWMainWrapper<T>;
export default createWrapper;
//# sourceMappingURL=wrapper.d.ts.map