import { EventEmitter } from 'events';
import { SimpleOutStream, SimpleInStream } from './stream';
import { ModuleWorker } from './ModuleWorker';
import { ensureDir } from './utils';
import { ModuleWorkerClient } from './ModuleWorkerClient';
function loadHelper(fn) {
    if (!fn) {
        return Promise.resolve(null);
    }
    return Promise.resolve(fn()).then((modOrDefault) => {
        if (modOrDefault && typeof modOrDefault.default !== 'undefined') {
            return modOrDefault.default;
        }
        return modOrDefault;
    });
}
function string2arrayBuffer(str) {
    const buf = new ArrayBuffer(str.length * 2); // 2 bytes for each char
    const bufView = new Uint16Array(buf);
    for (let i = 0; i < str.length; i++) {
        bufView[i] = str.charCodeAt(i);
    }
    return buf;
}
function buildAsyncFunctions(that, functions = {}) {
    const obj = {};
    Object.keys(functions).forEach((k) => {
        obj[k] = (...args) => that.sync().then((mod) => mod.fn[k](...args));
    });
    return obj;
}
function buildSyncFunctions(mod, functions = {}) {
    const obj = {};
    Object.entries(functions).forEach(([k, v]) => {
        obj[k] = mod.cwrap(k, v.returnType, v.arguments);
    });
    return obj;
}
class EMScriptWrapper extends EventEmitter {
    constructor(_loaders, options = {}) {
        super();
        this._loaders = _loaders;
        this.options = options;
        this.stdout = new SimpleOutStream();
        this.stderr = new SimpleOutStream();
        this.stdin = new SimpleInStream();
        this.moduleLoader = null;
        this.readySemaphore = null;
        this._sync = null;
        this.environmentVariables = {};
        this.ranMainOnce = false;
        this.fn = buildAsyncFunctions(this, options.functions);
        this.simpleFileSystem = {
            ensureDir: (dir) => this.fileSystem.then((fs) => {
                ensureDir(fs, dir);
                return true;
            }),
            readBinaryFile: (path) => this.fileSystem.then((fs) => {
                return fs.readFile(path);
            }),
            readTextFile: (path) => this.fileSystem.then((fs) => {
                return fs.readFile(path, { encoding: 'utf8', flags: 'r' });
            }),
            writeTextFile: (path, content) => this.fileSystem.then((fs) => {
                fs.writeFile(path, content, { encoding: 'utf8', flags: 'w' });
                return true;
            }),
            writeBinaryFile: (path, content) => this.fileSystem.then((fs) => {
                fs.writeFile(path, content);
                return true;
            })
        };
    }
    _load() {
        if (this.moduleLoader) {
            return this.moduleLoader;
        }
        let readyResolve = null;
        this.readySemaphore = new Promise((resolve) => readyResolve = resolve);
        this.moduleLoader = Promise.all([loadHelper(this._loaders.module), loadHelper(this._loaders.wasm), loadHelper(this._loaders.mem), loadHelper(this._loaders.data)]).then(([mod, wasm, mem, data]) => {
            const modOptions = {
                // readd missing new line
                print: (chunk) => this.stdout.push(`${chunk}\n`),
                printErr: (chunk) => this.stderr.push(`${chunk}\n`),
                stdin: () => this.stdin.read(),
                noInitialRun: true,
                noExitRuntime: true,
                onRuntimeInitialized: () => {
                    setTimeout(() => readyResolve(), 1);
                },
                quit: (status) => {
                    this.emit('quit', status);
                }
            };
            // console.log(wasm, data, mem);
            const toLocate = [];
            // WASM
            if (wasm instanceof ArrayBuffer || (typeof wasm === 'string' && !wasm.endsWith('.wasm'))) {
                // array buffer or a string which is an arraybuffer
                if (typeof wasm === 'string') {
                    wasm = string2arrayBuffer(wasm);
                }
                modOptions.wasmBinary = wasm;
            }
            else if (typeof wasm === 'string') {
                // location
                toLocate.push({ suffix: '.wasm', location: wasm });
            }
            // DATA
            if (data instanceof ArrayBuffer || (typeof data === 'string' && !data.endsWith('.data'))) {
                // array buffer or a string which is an arraybuffer
                const d = (typeof data === 'string') ? string2arrayBuffer(data) : data;
                modOptions.getPreloadedPackage = () => d;
            }
            else if (typeof data === 'string') {
                // location
                toLocate.push({ suffix: '.data', location: data });
            }
            // MemoryDump
            if (mem instanceof ArrayBuffer || (typeof mem === 'string' && !mem.endsWith('.mem'))) {
                // array buffer or a string which is an arraybuffer
                if (typeof mem === 'string') {
                    mem = string2arrayBuffer(mem);
                }
                modOptions.memoryInitializerRequest = { response: mem, status: 200 };
            }
            else if (typeof mem === 'string') {
                // location
                toLocate.push({ suffix: '.mem', location: mem });
            }
            if (toLocate.length > 0) {
                modOptions.locateFile = (name, prefix) => {
                    const entry = toLocate.find((d) => name.endsWith(d.suffix));
                    return entry ? entry.location : `${prefix || ''}${name}`;
                };
            }
            const m = mod(modOptions);
            // wrap module since it has a 'then' by itself and then the promise thinks it is another promise to wait for
            // however the then doesn't work properly
            return { mod: m };
        });
        return this.moduleLoader;
    }
    main(args) {
        return this.sync().then((mod) => mod.main(args));
    }
    run(args, stdin) {
        return this.sync().then((mod) => mod.run(args, stdin));
    }
    kill(signal) {
        return this.sync().then((mod) => mod.kill(signal));
    }
    get fileSystem() {
        return this._load().then((mod) => mod.mod.FS);
    }
    get module() {
        return this._load().then((mod) => mod.mod);
    }
    _callMain(mod, args) {
        let statusCode = 0;
        let statusError = null;
        const quitListener = (status, error) => {
            statusCode = status;
            statusError = error;
        };
        this.on('quit', quitListener);
        try {
            this.preMain(mod);
            mod.callMain(args || []);
            if (statusCode > 0 && statusError) {
                throw statusError;
            }
            return statusCode;
        }
        finally {
            this.off('quit', quitListener);
        }
    }
    preMain(mod) {
        // call to init the proper standard streams agains
        if (this.ranMainOnce && mod.globalCtors) {
            // globalctors: A demonstration of GCC Global Constructor: A function that is automatically called before main.
            mod.globalCtors();
        }
        this.ranMainOnce = true;
    }
    _runMain(mod, args, stdin) {
        let statusCode = 0;
        let statusError = null;
        let stdout = '';
        let stderr = '';
        const quitListener = (status, error) => {
            statusCode = status;
            statusError = error;
        };
        this.on('quit', quitListener);
        const stdoutListener = (chunk) => {
            stdout += chunk;
        };
        this.stdout.on('data', stdoutListener);
        const stderrListener = (chunk) => {
            stderr += chunk;
        };
        this.stderr.on('data', stderrListener);
        if (stdin) {
            this.stdin.clear();
            this.stdin.push(stdin);
        }
        try {
            this.preMain(mod);
            mod.callMain(args || []);
        }
        catch (error) {
            statusError = error;
        }
        finally {
            this.off('quit', quitListener);
            this.stdout.off('data', stdoutListener);
            this.stderr.off('data', stderrListener);
            if (stdin) {
                this.stdin.clear();
            }
        }
        return {
            stdout,
            stderr,
            exitCode: statusCode,
            error: statusError || undefined
        };
    }
    module2wrapper(mod) {
        const that = this;
        const environmentVariables = mod.ENV && typeof mod.ENV !== 'function' ? mod.ENV : {};
        // inject environment variables that where set before
        Object.assign(environmentVariables, this.environmentVariables);
        this.environmentVariables = environmentVariables;
        return {
            module: mod,
            fileSystem: mod.FS,
            environmentVariables,
            on(event, listener) {
                that.on(event, listener);
                return this;
            },
            once(event, listener) {
                that.once(event, listener);
                return this;
            },
            prependListener(event, listener) {
                that.prependListener(event, listener);
                return this;
            },
            prependOnceListener(event, listener) {
                that.prependOnceListener(event, listener);
                return this;
            },
            addListener(event, listener) {
                that.addListener(event, listener);
                return this;
            },
            removeListener(event, listener) {
                that.removeListener(event, listener);
                return this;
            },
            off(event, listener) {
                that.off(event, listener);
                return this;
            },
            removeAllListeners(event) {
                that.removeAllListeners(event);
                return this;
            },
            kill: (signal) => mod.abort(signal),
            stderr: this.stderr,
            stdin: this.stdin,
            stdout: this.stdout,
            main: (args) => this._callMain(mod, args),
            run: (args, stdin) => this._runMain(mod, args, stdin),
            fn: buildSyncFunctions(mod, this.options.functions),
            simpleFileSystem: {
                ensureDir: (dir) => {
                    ensureDir(mod.FS, dir);
                    return Promise.resolve(true);
                },
                readBinaryFile: (path) => {
                    return Promise.resolve(mod.FS.readFile(path));
                },
                readTextFile: (path) => {
                    return Promise.resolve(mod.FS.readFile(path, { encoding: 'utf8', flags: 'r' }));
                },
                writeTextFile: (path, content) => {
                    mod.FS.writeFile(path, content, { encoding: 'utf8', flags: 'w' });
                    return Promise.resolve(true);
                },
                writeBinaryFile: (path, content) => {
                    mod.FS.writeFile(path, content);
                    return Promise.resolve(true);
                }
            }
        };
    }
    sync() {
        if (this._sync) {
            return this._sync;
        }
        return this._sync = this._load()
            .then((mod) => this.readySemaphore.then(() => mod)) // wait for ready
            .then((mod) => {
            const wrapper = this.module2wrapper(mod.mod);
            this.emit('ready', wrapper);
            return wrapper;
        });
    }
    emit(event, ...args) {
        return super.emit(event, ...args);
    }
    // TODO if there is an exception in ccall and a converter was used (array or string) stackRestore won't be called
    createWorker(adapter) {
        return new ModuleWorker(this, adapter);
    }
    createWorkerClient(worker) {
        return new ModuleWorkerClient(worker, this.options);
    }
}
export function createWrapper(loaders, options) {
    return new EMScriptWrapper(typeof loaders === 'function' ? { module: loaders } : loaders, options);
}
export default createWrapper;
//# sourceMappingURL=wrapper.js.map