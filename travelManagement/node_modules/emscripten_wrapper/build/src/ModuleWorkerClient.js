import { EventEmitter } from 'events';
import { SimpleInStream, SimpleOutStream } from './stream';
export class ModuleWorkerClient extends EventEmitter {
    constructor(worker, options = {}) {
        super();
        this.worker = worker;
        this.stdout = new SimpleOutStream();
        this.stderr = new SimpleOutStream();
        this.stdin = new SimpleInStream();
        this.keyCounter = 0;
        this.worker.addEventListener('message', this.onMessage.bind(this));
        this.on('message', (msg) => {
            switch (msg.type) {
                case 'ready':
                    this.emit('ready');
                    break;
                case 'exit':
                    this.emit('exit', msg.code);
                    break;
                case 'quit':
                    this.emit('quit', msg.status);
                    break;
                case 'stdout':
                    this.stdout.push(msg.chunk);
                    break;
                case 'stderr':
                    this.stderr.push(msg.chunk);
                    break;
                case 'error':
                    this.emit('error', msg.error);
                    break;
            }
        });
        this.stdin.on('data', (chunk) => this.postMessage({ key: this.nextKey(), type: 'stdin', chunk }));
        this.stdin.on('clear', () => this.postMessage({ key: this.nextKey(), type: 'stdinClear' }));
        this.stdin.on('close', () => this.postMessage({ key: this.nextKey(), type: 'stdinClose' }));
        const obj = {};
        Object.keys(options.functions || {}).forEach((k) => {
            obj[k] = (...args) => this.sendAndWait({ type: 'fn', function: k, args }, [], (msg) => msg.type === 'fn', (msg) => msg.returnValue);
        });
        this.fn = obj;
        this.simpleFileSystem = {
            ensureDir: (path) => this.sendAndWaitOK({ type: 'ensureDir', path }),
            writeTextFile: (path, content) => this.sendAndWaitOK({ type: 'writeTextFile', path, content }),
            writeBinaryFile: (path, content) => this.sendAndWaitOK({ type: 'writeBinaryFile', path, content }),
            readTextFile: (path) => this.sendAndWait({ type: 'readTextFile', path }, [], (msg) => msg.type === 'readTextFile', (msg) => msg.content),
            readBinaryFile: (path) => this.sendAndWait({ type: 'readBinaryFile', path }, [], (msg) => msg.type === 'readBinaryFile', (msg) => msg.content)
        };
        this.environmentVariables = new Proxy({}, {
            get: (obj, prop) => {
                return obj[prop];
            },
            set: (obj, prop, value) => {
                obj[prop] = value;
                // forward to worker
                this.postMessage({ key: this.nextKey(), type: 'setEnv', name: prop, value });
                return true;
            }
        });
    }
    nextKey() {
        return (this.keyCounter++).toString();
    }
    postMessage(msg, transfer = []) {
        this.worker.postMessage(msg, transfer);
    }
    onMessage(ev) {
        const msg = ev.data;
        if (!msg.type || !msg.key) {
            console.log('no message type or key given');
        }
        this.emit('message', msg);
    }
    sendAndWait(msg, transfer, filter, handle) {
        return new Promise((resolve) => {
            const key = this.nextKey();
            const listener = (msg) => {
                if (msg.key !== key || !filter(msg)) {
                    return;
                }
                this.off('message', listener);
                resolve(handle(msg));
            };
            this.on('message', listener);
            this.postMessage(Object.assign({ key }, msg), transfer);
        });
    }
    sendAndWaitOK(msg, transfer = []) {
        return this.sendAndWait(msg, transfer, (msg) => msg.type === 'ok', () => true);
    }
    main(args) {
        return this.run(args).then((r) => r.exitCode);
    }
    run(args = [], stdin) {
        return this.sendAndWait({ type: 'run', args, stdin }, [], (msg) => msg.type === 'run', (msg) => {
            return {
                error: msg.error,
                exitCode: msg.exitCode,
                stderr: msg.stderr,
                stdout: msg.stdout
            };
        });
    }
    kill() {
        this.worker.terminate();
    }
    emit(event, ...args) {
        return super.emit(event, ...args);
    }
}
//# sourceMappingURL=ModuleWorkerClient.js.map