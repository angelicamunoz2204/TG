"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var interfaces_1 = require("../interfaces");
var utils_1 = require("./utils");
var path_1 = require("path");
function parseMethod(method) {
    switch (method) {
        case 'min': return interfaces_1.EMethod.MINIMIZE;
        case 'max': return interfaces_1.EMethod.MAXIMIZE;
        default: return interfaces_1.EMethod.SATISFY;
    }
}
exports.parseMethod = parseMethod;
function toFileNames(fileName, tmpDir, sep, data) {
    var name = path_1.basename(fileName || 'model', '.mzn');
    var modelFile = "" + tmpDir + sep + name + ".mzn";
    var dataFile = "" + tmpDir + sep + name + "." + (typeof data === 'string' ? 'dzn' : 'json');
    var oznFile = "" + tmpDir + sep + name + ".ozn";
    var fznFile = "" + tmpDir + sep + name + ".fzn";
    return { modelFile: modelFile, dataFile: dataFile, oznFile: oznFile, fznFile: fznFile };
}
exports.toFileNames = toFileNames;
function toSolveArguments(params, modelFile, dataFile, stats, data) {
    var args = [
        '--allow-multiple-assignments'
    ];
    if (stats) {
        args.push('--solver-statistics');
    }
    if (params.all_solutions) {
        args.push('-a');
    }
    else if (params.nr_solutions != null) {
        args.push('-n', params.nr_solutions.toString());
    }
    if (params.processes != null) {
        args.push('-p', params.processes.toString());
    }
    if (params.random_seed != null) {
        args.push('-r', params.random_seed.toString());
    }
    if (params.free_search) {
        args.push('-f');
    }
    if (params.solver) {
        args.push('--solver', params.solver);
    }
    var code = params.model;
    args.push(modelFile);
    var filteredData = '';
    if (typeof data === 'string') {
        args.push(dataFile);
        filteredData = data;
    }
    else if (data) {
        data = Object.assign({}, data); // copy
        for (var _i = 0, _a = Object.entries(data); _i < _a.length; _i++) {
            var _b = _a[_i], k = _b[0], v = _b[1];
            if (interfaces_1.isEnumValue(v)) {
                // enum value are not supported in json format yet
                code += k + " = " + v.e + ";\n";
                delete data[k];
            }
            else if (interfaces_1.isSetRange(v)) {
                // range syntax
                code += k + " = " + v.set[0][0] + ".." + v.set[0][1] + ";\n";
                delete data[k];
            }
            else if (interfaces_1.isSet(v) && v.set.length > 0 && interfaces_1.isEnumValue(v.set[0])) {
                // set of enums
                code += k + " = {" + v.set.map(function (vi) { return vi.e; }).join(', ') + "};\n";
                delete data[k];
            }
        }
        if (Object.keys(data).length > 0) {
            args.push(dataFile);
            filteredData = JSON.stringify(data, null, 2);
        }
    }
    return {
        args: args,
        model: code,
        filteredData: filteredData
    };
}
exports.toSolveArguments = toSolveArguments;
function toAnalyzeArguments(modelFile, params) {
    var args = ['--model-interface-only', '--model-types-only', modelFile];
    if (params.solver) {
        args.push('--solver', params.solver);
    }
    return {
        args: args
    };
}
exports.toAnalyzeArguments = toAnalyzeArguments;
function checkIsFlag(stdFlags) {
    return function (flag) { return stdFlags.includes(flag); };
}
function toSolverArguments(params, info, stats) {
    if (stats === void 0) { stats = true; }
    var args = [];
    var isValid = typeof info.SOLVER_MSC_FILE === 'string' || !info.SOLVER_MSC_FILE.stdFlags ? function () { return true; } : checkIsFlag(info.SOLVER_MSC_FILE.stdFlags);
    if (params.all_solutions && isValid('-a')) {
        args.push('-a');
    }
    else if (params.nr_solutions != null && isValid('-n')) {
        args.push('-n', params.nr_solutions.toString());
    }
    if (params.processes != null && isValid('-p')) {
        args.push('-p', params.processes.toString());
    }
    if (params.random_seed != null && isValid('-r')) {
        args.push('-r', params.random_seed.toString());
    }
    if (params.free_search && isValid('-f')) {
        args.push('-f');
    }
    if (stats && isValid('-s')) {
        args.push('-s'); // stats
    }
    args.push('-'); // use stdin
    return args;
}
exports.toSolverArguments = toSolverArguments;
function parseAnalyzeOutput(stdout) {
    var output = utils_1.normalize(stdout);
    var outputs = utils_1.parseMultiObjects(output);
    var interfaceDesc = JSON.parse(outputs[0]);
    var modelTypes = JSON.parse(outputs[1]);
    var varTypes = modelTypes.var_types;
    var vars = Object.entries(varTypes.vars).map(function (_a) {
        var key = _a[0], v = _a[1];
        return Object.assign({ key: key, dim: 0 }, v);
    });
    var byVar = new Map(vars.map(function (v) { return [v.key, v]; }));
    return {
        vars: vars,
        inputs: Object.entries(interfaceDesc.input).map(function (_a) {
            var key = _a[0], v = _a[1];
            return Object.assign({ key: key, dim: 0 }, byVar.get(key) || {}, v);
        }),
        outputs: Object.entries(interfaceDesc.output).map(function (_a) {
            var key = _a[0], v = _a[1];
            return Object.assign({ key: key, dim: 0 }, byVar.get(key) || {}, v);
        }),
        enums: varTypes.enums || [],
        method: parseMethod(interfaceDesc.method)
    };
}
exports.parseAnalyzeOutput = parseAnalyzeOutput;
//# sourceMappingURL=common.js.map