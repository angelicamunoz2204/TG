"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var interfaces_1 = require("../interfaces");
var logic_1 = require("./logic");
var abort_1 = require("./abort");
var utils_1 = require("./utils");
var common_1 = require("./common");
var parseError_1 = tslib_1.__importDefault(require("../output/parseError"));
var result_1 = require("../output/result");
function analyzeEmbedded(mzn, solvers, paramsOrCode, options, coptions) {
    if (options === void 0) { options = {}; }
    if (coptions === void 0) { coptions = {}; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var params, tmpDir, modelFile, cleanUpExtraIncludeFiles, _a, includePath, cleanup, extraArgs;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    params = typeof paramsOrCode === 'string' ? { model: paramsOrCode } : paramsOrCode;
                    if (!params.solver && solvers.length > 0) {
                        // default solver if available
                        params.solver = solvers[0].SOLVER_ID;
                    }
                    tmpDir = utils_1.randomBaseDir();
                    modelFile = common_1.toFileNames(options.fileName, tmpDir, '/').modelFile;
                    cleanUpExtraIncludeFiles = null;
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, , 5, 9]);
                    return [4 /*yield*/, mzn.simpleFileSystem.ensureDir(tmpDir)];
                case 2:
                    _b.sent();
                    return [4 /*yield*/, mzn.simpleFileSystem.writeTextFile(modelFile, params.model)];
                case 3:
                    _b.sent();
                    return [4 /*yield*/, logic_1.createExtraIncludeFiles(tmpDir, '/', mzn.simpleFileSystem, Object.assign({}, coptions.extraIncludeFiles || {}, options.extraIncludeFiles || {}))];
                case 4:
                    _a = _b.sent(), includePath = _a.includePath, cleanup = _a.cleanup;
                    if (options.signal && options.signal.aborted) {
                        throw new abort_1.AbortException();
                    }
                    extraArgs = [];
                    if (includePath) {
                        extraArgs.push('-I', includePath);
                        cleanUpExtraIncludeFiles = cleanup;
                    }
                    return [2 /*return*/, logic_1.analyzeImpl(mzn, params, extraArgs, modelFile, options.signal)];
                case 5: 
                // cleanup file system tho there is no delete so write with 0
                return [4 /*yield*/, mzn.simpleFileSystem.writeTextFile(modelFile, '')];
                case 6:
                    // cleanup file system tho there is no delete so write with 0
                    _b.sent();
                    if (!cleanUpExtraIncludeFiles) return [3 /*break*/, 8];
                    return [4 /*yield*/, cleanUpExtraIncludeFiles()];
                case 7:
                    _b.sent();
                    _b.label = 8;
                case 8: return [7 /*endfinally*/];
                case 9: return [2 /*return*/];
            }
        });
    });
}
exports.analyzeEmbedded = analyzeEmbedded;
var DEBOUNCE_PARSE = 500; // debounce for 500ms before a partial parse attempt
var ReturnException = /** @class */ (function (_super) {
    tslib_1.__extends(ReturnException, _super);
    function ReturnException(out) {
        var _this = _super.call(this) || this;
        _this.out = out;
        return _this;
    }
    return ReturnException;
}(Error));
function nextParseChunk(out) {
    var seps = result_1.findOutputSeparator(out, 0, true);
    if (seps.index < 0) {
        return;
    }
    return out.slice(0, seps.index + seps.sep.length);
}
function solveCommonEmbedded(createBuilder, _a) {
    var mzn = _a.mzn, solvers = _a.solvers, paramsOrCode = _a.paramsOrCode, data = _a.data, options = _a.options, coptions = _a.coptions, stats = _a.stats;
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var params, solver, tmpDir, _b, modelFile, dataFile, oznFile, fznFile, _c, args, model, filteredData, _d, includePath, cleanup, builder, output, error_1, fznContent, compiled, error_2, parseOutput, solve, acc_1, r_1, solutionStream_1, debouncePartialParsing_1, partialParseRunning_1, partialParseError_1, parsePartial_1, parsePartialDebounced_1, collectSolutionStream, r, rest;
        return tslib_1.__generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    params = typeof paramsOrCode === 'string' ? { model: paramsOrCode } : paramsOrCode;
                    if (!params.solver && solvers.length > 0) {
                        params.solver = solvers[0].SOLVER_ID;
                    }
                    solver = mzn.chooseSolver(solvers, params.solver);
                    tmpDir = utils_1.randomBaseDir();
                    _b = common_1.toFileNames(options.fileName, tmpDir, '/', data), modelFile = _b.modelFile, dataFile = _b.dataFile, oznFile = _b.oznFile, fznFile = _b.fznFile;
                    _c = common_1.toSolveArguments(params, modelFile, dataFile, stats, data), args = _c.args, model = _c.model, filteredData = _c.filteredData;
                    // console.log(modelFile, dataFile, oznFile, fznFile, args, model, filteredData, gecodeArgs);
                    if (options.signal && options.signal.aborted) {
                        throw new abort_1.AbortException();
                    }
                    //console.log('write file');
                    return [4 /*yield*/, mzn.simpleFileSystem.ensureDir(tmpDir)];
                case 1:
                    //console.log('write file');
                    _e.sent();
                    return [4 /*yield*/, mzn.simpleFileSystem.writeTextFile(modelFile, model)];
                case 2:
                    _e.sent();
                    if (!filteredData) return [3 /*break*/, 4];
                    return [4 /*yield*/, mzn.simpleFileSystem.writeTextFile(dataFile, filteredData)];
                case 3:
                    _e.sent();
                    _e.label = 4;
                case 4: return [4 /*yield*/, logic_1.createExtraIncludeFiles(tmpDir, '/', mzn.simpleFileSystem, Object.assign({}, coptions.extraIncludeFiles || {}, options.extraIncludeFiles || {}))];
                case 5:
                    _d = _e.sent(), includePath = _d.includePath, cleanup = _d.cleanup;
                    if (options.signal && options.signal.aborted) {
                        throw new abort_1.AbortException();
                    }
                    //console.log('analyzse file');
                    if (includePath) {
                        args.push('-I', includePath);
                    }
                    return [4 /*yield*/, createBuilder(params, includePath, modelFile, dataFile)];
                case 6:
                    builder = _e.sent();
                    if (!!solver) return [3 /*break*/, 12];
                    _e.label = 7;
                case 7:
                    _e.trys.push([7, 9, 10, 12]);
                    mzn.stdout.on('data', builder.stdout);
                    mzn.stderr.on('data', builder.stderr);
                    return [4 /*yield*/, mzn.run(args)];
                case 8:
                    output = _e.sent();
                    if (output.exitCode) {
                        return [2 /*return*/, builder.onSolveError(output.stderr)];
                    }
                    return [2 /*return*/, builder.build()];
                case 9:
                    error_1 = _e.sent();
                    if (error_1 instanceof interfaces_1.BackendException) {
                        throw error_1;
                    }
                    return [2 /*return*/, builder.onSolveError(String(error_1))];
                case 10:
                    mzn.stdout.off('data', builder.stdout);
                    mzn.stderr.off('data', builder.stderr);
                    // cleanup file system tho there is no delete so write with 0
                    return [4 /*yield*/, Promise.all([
                            mzn.simpleFileSystem.writeTextFile(modelFile, ''),
                            filteredData ? mzn.simpleFileSystem.writeTextFile(dataFile, '') : Promise.resolve(null),
                            cleanup ? cleanup() : Promise.resolve(null),
                        ])];
                case 11:
                    // cleanup file system tho there is no delete so write with 0
                    _e.sent();
                    return [7 /*endfinally*/];
                case 12:
                    fznContent = '';
                    _e.label = 13;
                case 13:
                    _e.trys.push([13, 16, 17, 19]);
                    args.push('--compile');
                    args.push('--output-fzn-to-file', fznFile);
                    args.push('--output-ozn-to-file', oznFile);
                    return [4 /*yield*/, mzn.run(args)];
                case 14:
                    compiled = _e.sent();
                    if (compiled.exitCode) {
                        return [2 /*return*/, builder.onCompileError(compiled.stderr)];
                    }
                    builder.stdout(compiled.stdout);
                    builder.stderr(compiled.stderr);
                    return [4 /*yield*/, mzn.simpleFileSystem.readTextFile(fznFile)];
                case 15:
                    fznContent = _e.sent();
                    return [3 /*break*/, 19];
                case 16:
                    error_2 = _e.sent();
                    if (error_2 instanceof interfaces_1.BackendException) {
                        throw error_2;
                    }
                    return [2 /*return*/, builder.onCompileError(String(error_2))];
                case 17: 
                // cleanup file system tho there is no delete so write with 0
                return [4 /*yield*/, Promise.all([
                        mzn.simpleFileSystem.writeTextFile(modelFile, ''),
                        filteredData ? mzn.simpleFileSystem.writeTextFile(dataFile, '') : Promise.resolve(null),
                        cleanup ? cleanup() : Promise.resolve(null),
                        mzn.simpleFileSystem.writeTextFile(fznFile, '')
                    ])];
                case 18:
                    // cleanup file system tho there is no delete so write with 0
                    _e.sent();
                    return [7 /*endfinally*/];
                case 19:
                    parseOutput = function (output, last) {
                        if (options.signal && options.signal.aborted) {
                            throw new abort_1.AbortException();
                        }
                        var exe = mzn.run(['--solver', params.solver, '--ozn-file', oznFile], output);
                        return Promise.resolve(exe).then(function (r) {
                            if (r.exitCode) {
                                return builder.onOutputError(r.stderr);
                            }
                            return last ? builder.build() : null;
                        }).catch(function (error) {
                            if (error instanceof interfaces_1.BackendException) {
                                throw error;
                            }
                            return builder.onOutputError(String(error));
                        });
                    };
                    solve = function (solverInstance, stdout) {
                        var solverArgs = common_1.toSolverArguments(params, solver, stats);
                        solverInstance.stdout.on('data', stdout);
                        // run Gecode
                        var exe = solverInstance.run(solverArgs, fznContent);
                        return Promise.resolve(exe).then(function (r) {
                            solverInstance.stdout.off('data', stdout);
                            if (r.exitCode) {
                                return builder.onSolveError(r.stderr);
                            }
                            builder.stderr(r.stderr);
                            return null;
                        }).catch(function (error) {
                            solverInstance.stdout.off('data', stdout);
                            if (error instanceof ReturnException) {
                                return error.out;
                            }
                            if (error instanceof interfaces_1.BackendException) {
                                throw error;
                            }
                            return builder.onSolveError(String(error));
                        });
                    };
                    _e.label = 20;
                case 20:
                    _e.trys.push([20, , 28, 30]);
                    if (options.signal && options.signal.aborted) {
                        throw new abort_1.AbortException();
                    }
                    if (!(!builder.streamResults || !mzn.threaded)) return [3 /*break*/, 23];
                    acc_1 = '';
                    return [4 /*yield*/, solve(solver, function (chunk) { return acc_1 += chunk; })];
                case 21:
                    r_1 = _e.sent();
                    if (r_1) {
                        return [2 /*return*/, r_1];
                    }
                    mzn.stdout.on('data', builder.stdout);
                    mzn.stderr.on('data', builder.stderr);
                    return [4 /*yield*/, parseOutput(acc_1, true)];
                case 22: return [2 /*return*/, (_e.sent())];
                case 23:
                    solutionStream_1 = '';
                    debouncePartialParsing_1 = -1;
                    partialParseRunning_1 = null;
                    partialParseError_1 = null;
                    parsePartial_1 = function (anotherRound) {
                        debouncePartialParsing_1 = -1;
                        var chunk = nextParseChunk(solutionStream_1);
                        if (!chunk || partialParseRunning_1) {
                            return;
                        }
                        // can partially parse the output
                        // remove chunk
                        solutionStream_1 = solutionStream_1.slice(chunk.length);
                        // parse sub
                        var r = parseOutput(chunk, false);
                        partialParseRunning_1 = r;
                        r.then(function (out) {
                            partialParseRunning_1 = null;
                            if (out) {
                                partialParseError_1 = new ReturnException(out);
                                return;
                            }
                            anotherRound();
                        });
                        r.catch(function (error) {
                            partialParseRunning_1 = null;
                            partialParseError_1 = error;
                        });
                    };
                    parsePartialDebounced_1 = function () {
                        if (!solutionStream_1 || !nextParseChunk(solutionStream_1) || partialParseRunning_1) {
                            return;
                        }
                        // have a chunk, debounce
                        // clear old for debouncing
                        if (debouncePartialParsing_1 >= 0) {
                            clearTimeout(debouncePartialParsing_1);
                            debouncePartialParsing_1 = -1;
                        }
                        debouncePartialParsing_1 = self.setTimeout(parsePartial_1, DEBOUNCE_PARSE, parsePartialDebounced_1);
                    };
                    collectSolutionStream = function (chunk) {
                        if (partialParseError_1) {
                            throw partialParseError_1;
                        }
                        solutionStream_1 += chunk;
                        parsePartialDebounced_1();
                    };
                    mzn.stdout.on('data', builder.stdout);
                    mzn.stderr.on('data', builder.stderr);
                    return [4 /*yield*/, solve(solver, collectSolutionStream)];
                case 24:
                    r = _e.sent();
                    if (r) {
                        return [2 /*return*/, r];
                    }
                    rest = solutionStream_1;
                    solutionStream_1 = '';
                    // stop sheduled
                    if (debouncePartialParsing_1 >= 0) {
                        clearTimeout(debouncePartialParsing_1);
                        debouncePartialParsing_1 = -1;
                    }
                    if (!partialParseRunning_1) return [3 /*break*/, 26];
                    return [4 /*yield*/, partialParseRunning_1];
                case 25:
                    _e.sent();
                    _e.label = 26;
                case 26:
                    if (partialParseError_1 instanceof ReturnException) {
                        return [2 /*return*/, partialParseError_1.out];
                    }
                    if (partialParseError_1) {
                        throw partialParseError_1;
                    }
                    if (!rest) {
                        return [2 /*return*/, builder.build()];
                    }
                    return [4 /*yield*/, parseOutput(rest, true)];
                case 27: 
                // have to run it one more time
                return [2 /*return*/, (_e.sent())];
                case 28:
                    mzn.stdout.off('data', builder.stdout);
                    mzn.stderr.off('data', builder.stderr);
                    return [4 /*yield*/, mzn.simpleFileSystem.writeTextFile(oznFile, '')];
                case 29:
                    _e.sent();
                    return [7 /*endfinally*/];
                case 30: return [2 /*return*/];
            }
        });
    });
}
function solveEmbedded(mzn, solvers, paramsOrCode, data, options, coptions) {
    if (options === void 0) { options = {}; }
    if (coptions === void 0) { coptions = {}; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var createBuilder;
        var _this = this;
        return tslib_1.__generator(this, function (_a) {
            createBuilder = function (params, includePath, modelFile, dataFile) { return tslib_1.__awaiter(_this, void 0, void 0, function () {
                var extraArgs, analyzed, builder, stderr;
                return tslib_1.__generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            extraArgs = [];
                            if (includePath) {
                                extraArgs.push('-I', includePath);
                            }
                            return [4 /*yield*/, logic_1.analyzeImpl(mzn, params, extraArgs, modelFile, options.signal)];
                        case 1:
                            analyzed = _a.sent();
                            builder = new result_1.ResultBuilder(analyzed, params, options.onPartialResult);
                            stderr = '';
                            return [2 /*return*/, {
                                    streamResults: options.onPartialResult != null,
                                    stdout: function (chunk) { return builder.push(chunk); },
                                    stderr: function (chunk) { return stderr += chunk; },
                                    onCompileError: function (stderr) {
                                        throw new interfaces_1.BackendException(parseError_1.default(stderr, modelFile, dataFile));
                                    },
                                    onSolveError: function (stderr) {
                                        throw new interfaces_1.BackendException(parseError_1.default(stderr, modelFile, dataFile));
                                    },
                                    onOutputError: function (stderr) {
                                        throw new interfaces_1.BackendException(parseError_1.default(stderr, modelFile, dataFile));
                                    },
                                    build: builder.build.bind(builder)
                                }];
                    }
                });
            }); };
            return [2 /*return*/, solveCommonEmbedded(createBuilder, { mzn: mzn, solvers: solvers, paramsOrCode: paramsOrCode, data: data, options: options, coptions: coptions, stats: true })];
        });
    });
}
exports.solveEmbedded = solveEmbedded;
function solveRawEmbedded(mzn, solvers, paramsOrCode, data, options, coptions) {
    if (options === void 0) { options = {}; }
    if (coptions === void 0) { coptions = {}; }
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var createBuilder;
        return tslib_1.__generator(this, function (_a) {
            createBuilder = function () {
                var stdout = '';
                var onChunk = function (chunk) {
                    stdout += chunk;
                    if (options.onChunk && chunk) {
                        options.onChunk(chunk);
                    }
                };
                return Promise.resolve({
                    streamResults: options.onChunk != null,
                    stdout: onChunk,
                    stderr: function (chunk) { return stdout += chunk; },
                    onCompileError: function (stderr) {
                        return stderr;
                    },
                    onSolveError: function (stderr) {
                        return stderr;
                    },
                    onOutputError: function (stderr) {
                        return stderr;
                    },
                    build: function () { return stdout; }
                });
            };
            return [2 /*return*/, solveCommonEmbedded(createBuilder, { mzn: mzn, solvers: solvers, paramsOrCode: paramsOrCode, data: data, options: options, coptions: coptions, stats: options.stats !== false })];
        });
    });
}
exports.solveRawEmbedded = solveRawEmbedded;
//# sourceMappingURL=embedded.js.map