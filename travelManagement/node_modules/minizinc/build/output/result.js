"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var interfaces_1 = require("../interfaces");
var utils_1 = require("../internal/utils");
function parseStatus(output, method) {
    if (output.includes('=ERROR=')) {
        return interfaces_1.EStatus.ERROR;
    }
    if (output.includes('=UNSATISFIABLE=')) {
        return interfaces_1.EStatus.UNSATISFIABLE;
    }
    if (output.includes('=UNSATorUNBOUNDED=') || output.includes('=UNBOUNDED=')) {
        return interfaces_1.EStatus.UNBOUNDED;
    }
    if (output.includes('==========')) {
        return method === interfaces_1.EMethod.SATISFY ? interfaces_1.EStatus.ALL_SOLUTIONS : interfaces_1.EStatus.OPTIMAL_SOLUTION;
    }
    if (output.includes('----------')) {
        return method === interfaces_1.EMethod.SATISFY ? interfaces_1.EStatus.OPTIMAL_SOLUTION : interfaces_1.EStatus.SATISFIED;
    }
    return interfaces_1.EStatus.UNKNOWN;
}
function isComplete(status, solutions, params, method) {
    if (method === interfaces_1.EMethod.SATISFY) {
        if (params.all_solutions) {
            return status === interfaces_1.EStatus.ALL_SOLUTIONS;
        }
        if (params.nr_solutions) {
            return solutions.length === params.nr_solutions;
        }
        return status === interfaces_1.EStatus.SATISFIED;
    }
    return status === interfaces_1.EStatus.OPTIMAL_SOLUTION;
}
function parsePartialObject(line) {
    line = line.trim();
    if (line.length === 0) {
        return { r: null, line: line };
    }
    if (!line.startsWith('{')) {
        return { r: null, line: line };
    }
    var objects = utils_1.parseMultiObjects(line);
    var r = {};
    var unparsed = '';
    for (var _i = 0, objects_1 = objects; _i < objects_1.length; _i++) {
        var obj = objects_1[_i];
        try {
            Object.assign(r, JSON.parse(obj));
        }
        catch (error) {
            console.warn('cannot parse line: ', obj);
            unparsed = "" + unparsed + (unparsed.length > 0 ? '\n' : '') + obj;
        }
    }
    return { r: r, line: unparsed };
}
function findOutputSeparator(output, start, findLast) {
    if (findLast === void 0) { findLast = false; }
    var separators = ['%'.repeat(10), '-'.repeat(10), '='.repeat(10)];
    if (findLast) {
        var rsep = separators.slice().reverse();
        for (var _i = 0, rsep_1 = rsep; _i < rsep_1.length; _i++) {
            var sep = rsep_1[_i];
            var index = output.lastIndexOf(sep, start);
            if (index >= 0) {
                return { index: index, sep: sep, isHeader: sep === separators[0] };
            }
        }
    }
    else {
        for (var _a = 0, separators_1 = separators; _a < separators_1.length; _a++) {
            var sep = separators_1[_a];
            var index = output.indexOf(sep, start);
            if (index >= 0) {
                return { index: index, sep: sep, isHeader: sep === separators[0] };
            }
        }
    }
    return { index: -1, sep: separators[separators.length - 1], isHeader: false };
}
exports.findOutputSeparator = findOutputSeparator;
var ResultBuilder = /** @class */ (function () {
    function ResultBuilder(meta, params, callback) {
        this.meta = meta;
        this.params = params;
        this.callback = callback;
        this.header = {};
        this.extraHeader = '';
        this.output = '';
        this.solutions = [];
        this.status = interfaces_1.EStatus.UNKNOWN;
        this.statistics = undefined;
    }
    ResultBuilder.prototype.push = function (output) {
        var bak = this.output + output;
        this.output = this.parsePartial(bak);
        // console.log(`partial: "${bak}" after: "${this.output}"`);
    };
    ResultBuilder.prototype.build = function () {
        // rest
        this.parsePartial(this.output, true);
        return this.buildResult();
    };
    ResultBuilder.prototype.buildResult = function () {
        return {
            status: this.status,
            solutions: this.solutions,
            header: this.header,
            extraHeader: this.extraHeader,
            objective: this.solutions.length > 0 ? this.solutions[this.solutions.length - 1].objective : undefined,
            outputs: this.meta.outputs,
            complete: isComplete(this.status, this.solutions, this.params, this.meta.method),
            statistics: this.statistics
        };
    };
    ResultBuilder.prototype.parseStats = function (output) {
        var lines = output.split('\n').filter(function (d) { return d.trim().length > 0; });
        var rest = [];
        var stat = {};
        for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
            var line = lines_1[_i];
            if (line.startsWith('%%%mzn-stat-end')) {
                continue;
            }
            // don't reuse regex to avoid multi line thing
            var re = /^%%%mzn-stat:? (.+)=([\d,.]+)$/gm;
            var match = re.exec(line);
            if (!match) {
                rest.push(line);
                continue;
            }
            stat[match[1]] = parseFloat(match[2]);
        }
        if (Object.keys(stat).length > 0) {
            this.statistics = Object.assign({}, stat);
        }
        return rest.join('\n');
    };
    ResultBuilder.prototype.parsePartial = function (output, isAll) {
        if (isAll === void 0) { isAll = false; }
        var wasEndingWithNewLine = output.endsWith('\n');
        output = utils_1.normalize(output);
        if (this.status === interfaces_1.EStatus.UNKNOWN) {
            this.status = parseStatus(output, this.meta.method);
        }
        else if (this.meta.method === interfaces_1.EMethod.SATISFY && this.status === interfaces_1.EStatus.OPTIMAL_SOLUTION && parseStatus(output, this.meta.method) === interfaces_1.EStatus.ALL_SOLUTIONS) {
            // better
            this.status = interfaces_1.EStatus.ALL_SOLUTIONS;
        }
        else if (this.meta.method !== interfaces_1.EMethod.SATISFY && this.status === interfaces_1.EStatus.SATISFIED && parseStatus(output, this.meta.method) === interfaces_1.EStatus.OPTIMAL_SOLUTION) {
            // better
            this.status = interfaces_1.EStatus.OPTIMAL_SOLUTION;
        }
        var start = 0;
        var end = -1;
        do {
            var rf = findOutputSeparator(output, start);
            end = rf.index;
            if (end < 0 && isAll) {
                end = output.length;
            }
            if (end < 0) {
                break;
            }
            var line = output.slice(start, end);
            var _a = parsePartialObject(line), obj = _a.r, unparsed = _a.line;
            if (obj && rf.isHeader) {
                // header case
                Object.assign(this.header, obj);
                this.extraHeader += unparsed;
                if (this.callback) {
                    this.callback('header', this.buildResult());
                }
            }
            else if (obj) {
                // solution case
                var objective = obj._objective;
                delete obj._objective;
                var solution = {
                    objective: objective,
                    assignments: obj,
                    extraOutput: unparsed
                };
                this.solutions.push(solution);
                if (this.callback) {
                    this.callback('solution', this.buildResult());
                }
            }
            else {
                // couldn't parse maybe statistics or an unparseable solution
                var rest = this.parseStats(line);
                if (rest) {
                    // a kind of solution but we cannot parse it properly
                    var solution = {
                        assignments: {},
                        extraOutput: rest
                    };
                    this.solutions.push(solution);
                    if (this.callback) {
                        this.callback('solution', this.buildResult());
                    }
                }
            }
            start = end + rf.sep.length;
        } while (start < output.length);
        // keep new line
        return start > output.length ? '' : "" + output.slice(start) + (wasEndingWithNewLine ? '\n' : '');
    };
    return ResultBuilder;
}());
exports.ResultBuilder = ResultBuilder;
function parseResult(output, meta, params) {
    var builder = new ResultBuilder(meta, params);
    builder.push(output);
    return builder.build();
}
exports.parseResult = parseResult;
//# sourceMappingURL=result.js.map