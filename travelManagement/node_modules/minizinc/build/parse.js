"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var interfaces_1 = require("./interfaces");
function formatPrimitiveValue(prop, value) {
    if (prop.enum_type) {
        // enum value
        return value.e;
    }
    return value.toString();
}
function formatValue(prop, value) {
    if (value == null) {
        return '';
    }
    if (prop.dim === 0 && !prop.set) {
        return formatPrimitiveValue(prop, value);
    }
    if (prop.set) {
        var vs = value;
        return vs.set.map(function (v) { return formatPrimitiveValue(prop, v); }).join('\n');
    }
    if (prop.dim === 1) {
        return value.map(function (v) { return formatPrimitiveValue(prop, v); }).join('\n');
    }
    var formatArray = function (arr, dim) {
        if (dim === 0) {
            return formatPrimitiveValue(prop, arr);
        }
        if (dim === 1) {
            return arr.map(function (v) { return formatArray(v, dim - 1); }).join(', ');
        }
        return arr.map(function (v) { return formatArray(v, dim - 1); }).join("\n" + '\n'.repeat(dim - 2));
    };
    return formatArray(value, prop.dim);
}
exports.formatValue = formatValue;
function parseValue(prop, value) {
    var parsePrimitive = function (value, prefix) {
        if (prefix === void 0) { prefix = ''; }
        if (prop.enum_type) { // always a string
            value = value.trim();
            if (value.length === 0) {
                return {
                    v: null,
                    error: prefix + " invalid enum"
                };
            }
            return { v: interfaces_1.createEnumValue(value) };
        }
        switch (prop.type) {
            case interfaces_1.EType.int:
                var v = parseInt(value, 10);
                if (value === '' || isNaN(v)) {
                    return {
                        v: null,
                        error: prefix + " invalid int"
                    };
                }
                return { v: v };
            case interfaces_1.EType.float:
                var vf = parseFloat(value);
                if (value === '' || isNaN(vf)) {
                    return {
                        v: null,
                        error: prefix + " invalid float"
                    };
                }
                return { v: vf };
            case interfaces_1.EType.bool:
                return { v: Boolean(value) };
            default:
                if (!value) {
                    return {
                        v: null,
                        error: prefix + " value required"
                    };
                }
                return { v: value };
        }
    };
    if (prop.dim === 0 && !prop.set) {
        return parsePrimitive(value);
    }
    if (prop.set || prop.dim === 1) {
        var values_1 = value.trim().split(/[ \n;,|]+/gm).map(function (d) { return d.trim(); }).filter(function (d) { return d.length > 0; });
        if (values_1.length === 0) {
            return {
                v: null,
                error: 'at least one value is required'
            };
        }
        var elems = values_1.map(function (v, i) { return parsePrimitive(v, i + 1 + ": "); });
        var errors_1 = elems.filter(function (v) { return v.error; }).map(function (v) { return v.error; });
        if (errors_1.length > 0) {
            return {
                v: null,
                error: errors_1.join(', ')
            };
        }
        var data = elems.map(function (v) { return v.v; });
        if (prop.set && (new Set(data)).size < data.length) {
            // verify unique values
            return {
                v: null,
                error: 'duplicate set entry'
            };
        }
        var v = void 0;
        if (prop.set) {
            v = {
                set: data
            };
        }
        else {
            v = data;
        }
        return { v: v };
    }
    if (prop.dim > 2) {
        // TODO support 3D matrices
        return {
            v: null,
            error: 'not yet supported'
        };
    }
    var values = value.trim().split(/[\n;|]+/gm).filter(function (d) { return d.trim().length > 0; }).map(function (d) { return d.trim().split(/[ ,]+/gm); });
    var rows = values.map(function (row, j) { return row.map(function (v, i) { return parsePrimitive(v, j + "x" + i); }); });
    var errors = [];
    for (var _i = 0, rows_1 = rows; _i < rows_1.length; _i++) {
        var row = rows_1[_i];
        for (var _a = 0, row_1 = row; _a < row_1.length; _a++) {
            var entry = row_1[_a];
            if (entry.error) {
                errors.push(entry.error);
            }
        }
    }
    if (errors.length > 0) {
        return {
            v: null,
            error: errors.join(', ')
        };
    }
    var lengths = new Set(rows.map(function (d) { return d.length; }));
    if (lengths.size > 1) {
        return {
            v: null,
            error: "different lengths: " + Array.from(lengths).sort(function (a, b) { return a - b; }).join(', ')
        };
    }
    return {
        v: rows.map(function (row) { return row.map(function (v) { return v.v; }); })
    };
}
exports.parseValue = parseValue;
function setAsArray(set) {
    if (!set || !interfaces_1.isSet(set)) {
        return [];
    }
    var values = set.set;
    if (interfaces_1.isSetRange(set)) {
        // range mode
        var start = set.set[0][0];
        var end = set.set[0][1];
        var r = [];
        for (var i = start; i <= end; i++) {
            r.push(i);
        }
        return r;
    }
    return values;
}
exports.setAsArray = setAsArray;
function setAsNamesArray(set) {
    return (interfaces_1.isSetRange(set) ? setAsArray(set) : setAsArray(set)).map(function (d) { return interfaces_1.isEnumValue(d) ? d.e : d.toString(); });
}
exports.setAsNamesArray = setAsNamesArray;
//# sourceMappingURL=parse.js.map