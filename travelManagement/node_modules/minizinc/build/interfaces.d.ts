import { IAbortSignal } from './internal/abort';
export { IAbortSignal, default as AbortSignal, AbortException } from './internal/abort';
export declare enum EType {
    unknown = "unknown",
    int = "int",
    float = "float",
    bool = "bool",
    string = "string",
    ann = "ann"
}
export interface ISet<T extends IPrimitiveValue = IPrimitiveValue> {
    set: T[];
}
export interface ISetRange {
    set: [[number, number]];
}
export interface IEnumValue {
    e: string;
}
export declare type IPrimitiveValue = string | boolean | number | IEnumValue;
export declare type IValue = IPrimitiveValue | IPrimitiveValue[] | IPrimitiveValue[][] | ISet | ISetRange;
export interface IDataObject {
    [key: string]: IValue;
}
export declare function isEnumValue(v: IValue): v is IEnumValue;
export declare function isSet(v: IValue): v is ISet;
export declare function isSetRange(v: IValue): v is ISetRange;
export declare type INameSet = ISet<IEnumValue | number> | ISetRange;
export declare function createEnumValue(value: string): IEnumValue;
export interface ITypeInfo {
    key: string;
    type: EType;
    dim: number;
    set?: boolean;
    dims?: string[];
    enum_type?: string;
    optional?: boolean;
}
export interface IHasTypeInfo {
    _prop: ITypeInfo;
}
export declare type ITypedValue = (IPrimitiveValue | IPrimitiveValue[] | IPrimitiveValue[][]) & IHasTypeInfo;
export interface ITypedDataObject {
    [key: string]: ITypedValue;
}
export declare function injectTypeInfo<T>(v: T, prop: ITypeInfo): T & IHasTypeInfo;
export declare function hasTypeInfo<T>(v: T): v is T & IHasTypeInfo;
export declare function asTypedValue(v: IValue, prop: ITypeInfo): ITypedValue;
export interface IEnteredValue extends ITypeInfo {
    valueAsString: string | number | boolean;
    error?: string;
    value: IValue | null;
}
export interface ILocation {
    line: number;
    columns: [number, number];
}
export interface IError {
    type: string;
    message: string;
    location?: ILocation;
    inputs?: ITypeInfo[];
}
export declare enum EMethod {
    SATISFY = "SATISFY",
    MINIMIZE = "MINIMIZE",
    MAXIMIZE = "MAXIMIZE"
}
export interface IModelMetaData {
    inputs: ITypeInfo[];
    outputs: ITypeInfo[];
    vars: ITypeInfo[];
    enums: string[];
    method: EMethod;
}
export interface IModelParams {
    model: string;
    solver?: string;
    random_seed?: number;
    all_solutions?: boolean;
    free_search?: boolean;
    processes?: number;
    nr_solutions?: number;
}
export interface ISolution {
    assignments: IDataObject;
    objective?: number;
    extraOutput?: string;
}
export declare enum EStatus {
    ERROR = "ERROR",
    UNKNOWN = "UNKNOWN",
    UNBOUNDED = "UNBOUNDED",
    UNSATISFIABLE = "UNSATISFIABLE",
    SATISFIED = "SATISFIED",
    ALL_SOLUTIONS = "ALL_SOLUTIONS",
    OPTIMAL_SOLUTION = "OPTIMAL_SOLUTION"
}
export interface IResult {
    status: EStatus;
    complete: boolean;
    outputs: ITypeInfo[];
    objective?: number;
    header: {
        [key: string]: any;
    };
    extraHeader?: string;
    solutions: ISolution[];
    statistics?: IStatistics;
}
export interface IStatistics {
    initTime: number;
    solveTime: number;
    solutions: number;
    variables: number;
    propagators: number;
    propagations: number;
    nodes: number;
    failures: number;
    restarts: number;
    peakDepth: number;
}
export interface IMiniZincOptions {
    fileName: string;
    signal: IAbortSignal;
    /**
     * extra files to add and include in a virtual extra include directory
     */
    extraIncludeFiles: {
        [filename: string]: string;
    };
}
export interface IMiniZincSolveOptions extends IMiniZincOptions {
    onPartialResult(type: 'solution' | 'header', result: IResult): void;
}
export interface IMiniZincSolveRawOptions extends IMiniZincOptions {
    onChunk(chunk: string): void;
    stats: boolean;
}
export interface ISolverConfiguration {
    id: string;
    description: string;
    name: string;
    tags: string[];
    version: string;
}
export interface IMiniZinc {
    analyze(paramsOrCode: string | IModelParams, options?: Partial<IMiniZincOptions>): Promise<IModelMetaData>;
    solve(paramsOrCode: string | IModelParams, data?: IDataObject | string, options?: Partial<IMiniZincSolveOptions>): Promise<IResult>;
    solveRaw(paramsOrCode: string | IModelParams, data?: IDataObject | string, options?: Partial<IMiniZincSolveRawOptions>): Promise<string>;
    resolveSolvers(): Promise<ISolverConfiguration[]>;
    version(): Promise<string>;
    terminate(): Promise<boolean>;
}
export interface IMiniZincConstructorOptions {
    /**
     * extra files to add and include in a virtual extra include directory
     */
    extraIncludeFiles: {
        [filename: string]: string;
    };
}
export interface IMiniZincConstructor {
    new (options: Partial<IMiniZincConstructorOptions>): IMiniZinc;
}
export declare class ProxyMiniZinc implements IMiniZinc {
    private readonly loader;
    private readonly options;
    private _instance;
    constructor(loader: () => Promise<{
        default: IMiniZincConstructor;
    }>, options?: Partial<IMiniZincConstructorOptions>);
    private readonly instance;
    analyze(code: IModelParams | string, options?: Partial<IMiniZincOptions>): Promise<IModelMetaData>;
    solve(params: IModelParams | string, data?: IDataObject | string, options?: Partial<IMiniZincSolveOptions>): Promise<IResult>;
    solveRaw(params: IModelParams | string, data?: IDataObject | string, options?: Partial<IMiniZincSolveRawOptions>): Promise<string>;
    resolveSolvers(): Promise<ISolverConfiguration[]>;
    version(): Promise<string>;
    terminate(): Promise<boolean>;
}
export declare class BackendException extends Error {
    readonly errors: IError[];
    constructor(errors: IError[]);
    readonly error: IError;
}
export declare function defaultValue(prop: ITypeInfo): IValue | null;
//# sourceMappingURL=interfaces.d.ts.map