"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var interfaces_1 = require("./interfaces");
// detect environment
var ENVIRONMENT_IS_WEB = typeof window === 'object';
var ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
// const ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof require === 'function' && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;
function createDriver(options) {
    var _this = this;
    if (options === void 0) { options = {}; }
    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
        // console.log('web environment detected use embedded version');
        return new interfaces_1.ProxyMiniZinc(function () { return Promise.resolve().then(function () { return tslib_1.__importStar(require('./EmbeddedMiniZinc')); }); }, options);
    }
    // node environment thus CLI might be available, test async
    // console.log('node environment detected');
    return new interfaces_1.ProxyMiniZinc(function () { return tslib_1.__awaiter(_this, void 0, void 0, function () {
        var cli;
        return tslib_1.__generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, Promise.resolve().then(function () { return tslib_1.__importStar(require('./CLIMiniZinc')); })];
                case 1:
                    cli = _a.sent();
                    if (cli.isCLIAvailable()) {
                        // console.log('found minizinc cli');
                        return [2 /*return*/, cli];
                    }
                    // fall back to forked version
                    // console.log('fork worker fallback');
                    return [2 /*return*/, Promise.resolve().then(function () { return tslib_1.__importStar(require('./ForkWorkerMiniZinc')); })];
            }
        });
    }); }, options);
}
exports.default = createDriver;
//# sourceMappingURL=driver.js.map