"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var decko_1 = require("decko");
var _1 = require(".");
var messages_1 = require("./internal/messages");
function createWindowReceiverChannel(win) {
    var w = win || window;
    var onByChannel = new Map();
    var onceByChannel = new Map();
    var onMessage = function (evt) {
        if (!evt.data || !evt.data.channel || !evt.source) {
            return;
        }
        var channel = evt.data.channel;
        var arg = evt.data.arg;
        var replyer = {
            reply: function (channel, arg) {
                evt.source.postMessage({ channel: channel, arg: arg }, evt.origin);
            }
        };
        if (onByChannel.has(channel)) {
            onByChannel.get(channel).forEach(function (l) { return l(replyer, arg); });
        }
        if (!onceByChannel.has(channel)) {
            return;
        }
        var r = onceByChannel.get(channel);
        onceByChannel.delete(channel);
        r.forEach(function (l) { return l(replyer, arg); });
    };
    return {
        on: function (channel, listener) {
            if (onByChannel.size === 0 && onceByChannel.size === 0) {
                w.addEventListener('message', onMessage);
            }
            if (!onByChannel.has(channel)) {
                onByChannel.set(channel, new Set());
            }
            onByChannel.get(channel).add(listener);
        },
        once: function (channel, listener) {
            if (onByChannel.size === 0 && onceByChannel.size === 0) {
                w.addEventListener('message', onMessage);
            }
            if (!onceByChannel.has(channel)) {
                onceByChannel.set(channel, new Set());
            }
            onceByChannel.get(channel).add(listener);
        },
        removeListener: function (channel, listener) {
            if (onByChannel.has(channel)) {
                var s = onByChannel.get(channel);
                s.delete(listener);
                if (s.size === 0) {
                    onByChannel.delete(channel);
                }
            }
            if (onceByChannel.has(channel)) {
                var s = onceByChannel.get(channel);
                s.delete(listener);
                if (s.size === 0) {
                    onceByChannel.delete(channel);
                }
            }
            if (onByChannel.size === 0 && onceByChannel.size === 0) {
                w.removeEventListener('message', onMessage);
            }
        }
    };
}
exports.createWindowReceiverChannel = createWindowReceiverChannel;
var MessagingReceiver = /** @class */ (function () {
    function MessagingReceiver(minizinc, channel) {
        this.minizinc = minizinc;
        this.channel = channel;
    }
    MessagingReceiver.prototype.abortListener = function (evt, arg) {
        var _this = this;
        var signal = new _1.AbortSignal();
        var listener = function () {
            signal.abort();
        };
        this.channel.once(messages_1.EVENT_ABORT + "-" + arg.key, listener);
        var reply = function (channel, arg) {
            _this.channel.removeListener(messages_1.EVENT_ABORT + "-" + arg.key, listener);
            if (!signal.aborted) {
                evt.reply(channel, arg);
                return;
            }
            evt.reply(channel, {
                error: [{
                        type: 'unknown',
                        message: 'The user aborted the request'
                    }]
            });
        };
        var options = Object.assign({}, arg.options, { signal: signal });
        return { reply: reply, options: options };
    };
    MessagingReceiver.prototype.onAnalyze = function (evt, arg) {
        var _a = this.abortListener(evt, arg), options = _a.options, reply = _a.reply;
        var r = this.minizinc.analyze(arg.code, options);
        r.then(function (metaData) { return reply(messages_1.EVENT_ANALYZE + "-" + arg.key, { metaData: metaData }); });
        r.catch(function (error) { return reply(messages_1.EVENT_ANALYZE + "-" + arg.key, { error: error.errors }); });
    };
    MessagingReceiver.prototype.onSolve = function (evt, arg) {
        var _a = this.abortListener(evt, arg), options = _a.options, reply = _a.reply;
        if (arg.streamSolutions) {
            options.onPartialResult = function (type, result) { return evt.reply(messages_1.EVENT_SOLVE_SOLUTION + "-" + arg.key, { type: type, result: result }); };
        }
        var r = this.minizinc.solve(typeof arg.code === 'string' ? { model: arg.code } : arg.code, arg.data, options);
        r.then(function (result) { return reply(messages_1.EVENT_SOLVE + "-" + arg.key, { result: result }); });
        r.catch(function (error) { return reply(messages_1.EVENT_SOLVE + "-" + arg.key, { error: error.errors }); });
    };
    MessagingReceiver.prototype.onSolveRaw = function (evt, arg) {
        var _a = this.abortListener(evt, arg), options = _a.options, reply = _a.reply;
        if (arg.streamChunks) {
            options.onChunk = function (chunk) { return evt.reply(messages_1.EVENT_SOLVE_RAW_CHUNK + "-" + arg.key, chunk); };
        }
        var r = this.minizinc.solveRaw(typeof arg.code === 'string' ? { model: arg.code } : arg.code, arg.data, options);
        r.then(function (result) { return reply(messages_1.EVENT_SOLVE_RAW + "-" + arg.key, result); });
        r.catch(function (error) { return reply(messages_1.EVENT_SOLVE_RAW + "-" + arg.key, error.toString()); });
    };
    MessagingReceiver.prototype.onResolveSolvers = function (evt, arg) {
        var r = this.minizinc.resolveSolvers();
        r.then(function (solvers) { return evt.reply(messages_1.EVENT_RESOLVE_SOLVERS + "-" + arg.key, { solvers: solvers }); });
        r.catch(function (error) { return evt.reply(messages_1.EVENT_RESOLVE_SOLVERS + "-" + arg.key, { error: error.errors }); });
    };
    MessagingReceiver.prototype.onVersion = function (evt, arg) {
        var r = this.minizinc.version();
        r.then(function (version) { return evt.reply(messages_1.EVENT_VERSION + "-" + arg.key, { version: version }); });
        r.catch(function (error) { return evt.reply(messages_1.EVENT_VERSION + "-" + arg.key, { error: error.errors }); });
    };
    MessagingReceiver.prototype.onTerminate = function (evt, arg) {
        var r = this.minizinc.terminate();
        r.then(function (ok) { return evt.reply(messages_1.EVENT_TERMINATE + "-" + arg.key, { ok: ok }); });
        r.catch(function (error) { return evt.reply(messages_1.EVENT_TERMINATE + "-" + arg.key, { error: error.errors }); });
    };
    MessagingReceiver.prototype.register = function () {
        this.channel.on(messages_1.EVENT_ANALYZE, this.onAnalyze);
        this.channel.on(messages_1.EVENT_SOLVE, this.onSolve);
        this.channel.on(messages_1.EVENT_SOLVE_RAW, this.onSolveRaw);
        this.channel.on(messages_1.EVENT_RESOLVE_SOLVERS, this.onResolveSolvers);
        this.channel.on(messages_1.EVENT_VERSION, this.onVersion);
        this.channel.on(messages_1.EVENT_TERMINATE, this.onTerminate);
    };
    MessagingReceiver.prototype.deregister = function () {
        this.channel.removeListener(messages_1.EVENT_ANALYZE, this.onAnalyze);
        this.channel.removeListener(messages_1.EVENT_SOLVE, this.onSolve);
        this.channel.removeListener(messages_1.EVENT_SOLVE_RAW, this.onSolveRaw);
        this.channel.removeListener(messages_1.EVENT_RESOLVE_SOLVERS, this.onResolveSolvers);
        this.channel.removeListener(messages_1.EVENT_VERSION, this.onVersion);
        this.channel.removeListener(messages_1.EVENT_TERMINATE, this.onTerminate);
    };
    tslib_1.__decorate([
        decko_1.bind
    ], MessagingReceiver.prototype, "onAnalyze", null);
    tslib_1.__decorate([
        decko_1.bind
    ], MessagingReceiver.prototype, "onSolve", null);
    tslib_1.__decorate([
        decko_1.bind
    ], MessagingReceiver.prototype, "onSolveRaw", null);
    tslib_1.__decorate([
        decko_1.bind
    ], MessagingReceiver.prototype, "onResolveSolvers", null);
    tslib_1.__decorate([
        decko_1.bind
    ], MessagingReceiver.prototype, "onVersion", null);
    tslib_1.__decorate([
        decko_1.bind
    ], MessagingReceiver.prototype, "onTerminate", null);
    return MessagingReceiver;
}());
exports.default = MessagingReceiver;
//# sourceMappingURL=MessagingReceiver.js.map