"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _1 = require(".");
var messages_1 = require("./internal/messages");
var utils_1 = require("./internal/utils");
function createWindowChannel(receiver, sender) {
    var s = sender || window;
    var onByChannel = new Map();
    var onceByChannel = new Map();
    var onMessage = function (evt) {
        if (!evt.data || !evt.data.channel || !evt.source || evt.source !== receiver) {
            return;
        }
        var channel = evt.data.channel;
        var arg = evt.data.arg;
        if (onByChannel.has(channel)) {
            onByChannel.get(channel).forEach(function (l) { return l(evt, arg); });
        }
        if (!onceByChannel.has(channel)) {
            return;
        }
        var r = onceByChannel.get(channel);
        onceByChannel.delete(channel);
        r.forEach(function (l) { return l(evt, arg); });
    };
    return {
        send: function (channel, msg) {
            receiver.postMessage({ channel: channel, arg: msg }, '*');
        },
        on: function (channel, listener) {
            if (onByChannel.size === 0 && onceByChannel.size === 0) {
                s.addEventListener('message', onMessage);
            }
            if (!onByChannel.has(channel)) {
                onByChannel.set(channel, new Set());
            }
            onByChannel.get(channel).add(listener);
        },
        once: function (channel, listener) {
            if (onByChannel.size === 0 && onceByChannel.size === 0) {
                s.addEventListener('message', onMessage);
            }
            if (!onceByChannel.has(channel)) {
                onceByChannel.set(channel, new Set());
            }
            onceByChannel.get(channel).add(listener);
        },
        removeListener: function (channel, listener) {
            if (onByChannel.has(channel)) {
                var s_1 = onByChannel.get(channel);
                s_1.delete(listener);
                if (s_1.size === 0) {
                    onByChannel.delete(channel);
                }
            }
            if (onceByChannel.has(channel)) {
                var s_2 = onceByChannel.get(channel);
                s_2.delete(listener);
                if (s_2.size === 0) {
                    onceByChannel.delete(channel);
                }
            }
            if (onByChannel.size === 0 && onceByChannel.size === 0) {
                s.removeEventListener('message', onMessage);
            }
        }
    };
}
exports.createWindowChannel = createWindowChannel;
var MessagingMiniZinc = /** @class */ (function () {
    function MessagingMiniZinc(channel, options) {
        if (options === void 0) { options = {}; }
        this.channel = channel;
        this.options = options;
        this.id = 0;
    }
    MessagingMiniZinc.prototype.analyze = function (code, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        return new Promise(function (resolve, reject) {
            var key = "key" + _this.id++;
            _this.channel.once(messages_1.EVENT_ANALYZE + "-" + key, function (_evt, arg) {
                if (arg.error) {
                    reject(new _1.BackendException(arg.error));
                }
                else {
                    resolve(arg.metaData);
                }
            });
            var safeOptions = utils_1.buildOptions(options, _this.options);
            _this.channel.send(messages_1.EVENT_ANALYZE, { key: key, code: code, options: safeOptions });
            if (!options.signal) {
                return;
            }
            options.signal.on('abort', function () { return _this.channel.send(messages_1.EVENT_ABORT + "-" + key); });
        });
    };
    MessagingMiniZinc.prototype.solve = function (code, data, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        return new Promise(function (resolve, reject) {
            var key = "key" + _this.id++;
            var partialResultListener = function (_evt, arg) {
                if (options.onPartialResult) {
                    options.onPartialResult(arg.type, arg.result);
                }
            };
            _this.channel.once(messages_1.EVENT_SOLVE + "-" + key, function (_evt, arg) {
                _this.channel.removeListener(messages_1.EVENT_SOLVE_SOLUTION + "-" + key, partialResultListener);
                if (arg.error) {
                    reject(new _1.BackendException(arg.error));
                }
                else {
                    resolve(arg.result);
                }
            });
            var safeOptions = utils_1.buildOptions(options, _this.options);
            if (options.onPartialResult) {
                _this.channel.on(messages_1.EVENT_SOLVE_SOLUTION + "-" + key, partialResultListener);
            }
            _this.channel.send(messages_1.EVENT_SOLVE, { key: key, code: code, data: data, options: safeOptions, streamSolutions: options.onPartialResult != null });
            if (!options.signal) {
                return;
            }
            options.signal.on('abort', function () { return _this.channel.send(messages_1.EVENT_ABORT + "-" + key); });
        });
    };
    MessagingMiniZinc.prototype.solveRaw = function (code, data, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        return new Promise(function (resolve) {
            var key = "key" + _this.id++;
            var chunkListener = function (_evt, arg) {
                if (options.onChunk) {
                    options.onChunk(arg);
                }
            };
            _this.channel.once(messages_1.EVENT_SOLVE_RAW + "-" + key, function (_evt, arg) {
                _this.channel.removeListener(messages_1.EVENT_SOLVE_RAW_CHUNK + "-" + key, chunkListener);
                resolve(arg);
            });
            var safeOptions = utils_1.buildOptions(options, _this.options);
            if (options.onChunk) {
                _this.channel.on(messages_1.EVENT_SOLVE_RAW_CHUNK + "-" + key, chunkListener);
            }
            _this.channel.send(messages_1.EVENT_SOLVE_RAW, { key: key, code: code, data: data, options: safeOptions, streamChunks: options.onChunk != null });
            if (!options.signal) {
                return;
            }
            options.signal.on('abort', function () { return _this.channel.send(messages_1.EVENT_ABORT + "-" + key); });
        });
    };
    MessagingMiniZinc.prototype.resolveSolvers = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var key = "key" + _this.id++;
            _this.channel.once(messages_1.EVENT_RESOLVE_SOLVERS + "-" + key, function (_evt, arg) {
                if (arg.error) {
                    reject(new _1.BackendException(arg.error));
                }
                else {
                    resolve(arg.solvers);
                }
            });
            _this.channel.send(messages_1.EVENT_RESOLVE_SOLVERS, { key: key });
        });
    };
    MessagingMiniZinc.prototype.version = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var key = "key" + _this.id++;
            _this.channel.once(messages_1.EVENT_VERSION + "-" + key, function (_evt, arg) {
                if (arg.error) {
                    reject(new _1.BackendException(arg.error));
                }
                else {
                    resolve(arg.version);
                }
            });
            _this.channel.send(messages_1.EVENT_VERSION, { key: key });
        });
    };
    MessagingMiniZinc.prototype.terminate = function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var key = "key" + _this.id++;
            _this.channel.once(messages_1.EVENT_TERMINATE + "-" + key, function (_evt, arg) {
                if (arg.error) {
                    reject(new _1.BackendException(arg.error));
                }
                else {
                    resolve(arg.ok);
                }
            });
            _this.channel.send(messages_1.EVENT_TERMINATE, { key: key });
        });
    };
    return MessagingMiniZinc;
}());
exports.default = MessagingMiniZinc;
//# sourceMappingURL=MessagingMiniZinc.js.map